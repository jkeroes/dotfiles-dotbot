## Git aliases

gg()   { git grep -E $* }
ggt()  { gg -i $* -- '*.t' }
ggtp() { gg -i $* -- '*.tp' }
ggm()  { gg -i $* -- '*.pm' }
ggp()  { gg -i $* -- '*.pm' '*.t' '*.pl' 'bin/' }
ggs()  { gg -i "(has|sub).*$*" -- '*.pm' '*.t' '*.pl' 'bin/' }

# see also: gca!
gcaa() { gca --amend }

is_dirty()     { [[ $(git diff -q) ]] && echo "1" }
branch_name()  { git symbolic-ref --short HEAD 2>/dev/null }
is_detached()  { [[ $(branch_name) ]] || echo "1" }
is_on_master() { [[ $(branch_name) == 'master' ]] && echo "1" }

# Usage: gria [COMMIT_ID]  # defaults to the merge-base commit-id
#
# Integrates fixup commits back to a provided COMMIT_ID
# without pausing to edit a commit-msg or back to the
# merge-base.
#
# See also: the`git fixup` alias.
gria() {
    local is_dirty=$(is_dirty)
    local is_detached=$(is_detached)
    local commit_id="$1"
    [[ $commit_id ]] || commit_id=$(git merge-base HEAD master)

    if [[ $is_detached ]]; then
        >&2 echo "Refusing to rebase from detached HEAD"
    else
        [[ $is_dirty ]] && git stash
        git -c core.editor=true -c sequence.editor=true rebase --interactive --autosquash $commit_id
        [[ $is_dirty ]] && git stash pop
    fi
}

mr() {
    lab 'merge_requests?author_name=Keroes&state=opened' | jq -r '.[] | [.web_url,"[\(.source_branch)]",.title] | join(" - ")'
}

## System aliases

syslocate() { locate $* | grep -vE '^/home|^/root' }

# work
if [ -d /ndn ]; then
    decrypt_user() {
        perl -MNdn::Dreamhost::MysqlUser -MNdn::Common::AuthPriv -E \
        'my $user = shift; my $MU = Ndn::Dreamhost::MysqlUser->Load({dh_id => "dh", user => $user}) \
        or die "User $user not found\n"; say Ndn::Common::AuthPriv::decryptPassword($MU->password_ndn)' $1
    }
fi

if [ -d ~/ndn ]; then
    function _dispatcher() {
        MYCMD=$1
        shift

        # no need in doing anything if we were not asked to
        if [[ -n $1 ]]; then
            # check and see if we know how to preform this action
            MYPATH=`which $MYCMD-$1`
            if [[ -n $MYPATH ]]; then
                # looks like there's a script to handle this action... pass it off
                shift; # because $1 is now in the path we don't need to pass it along
                eval "$MYPATH $*"
            else
                # trap errors
                echo "I do not know how to '$1', typo or possibly ask 'help' for ideas?"
            fi
        fi
    }

    function sup(){
        source ~/signup/bin/activate
        cd ~/signup
        # Ben's old line:  _dispatcher 'sup' $@
        [ -n $* ] && _dispatcher 'sup' $@
    }

    function ndn(){
        cd ~/ndn
        [ -n $* ] && _dispatcher 'ndn' $@
    }

    function sp(){
        cd ~/sitepanel
        [ -n $* ] && _dispatcher 'sp' $@
    }
fi
